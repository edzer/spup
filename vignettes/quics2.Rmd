---
title: "Modelling pipeline Quics"
author: "Kasia Sawicka"
date: "January 2017"
output: 
    html_document:
        toc: true
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA)
```


# Basic Design principles

- simplicity first (both for users and programmers)
- should work for 
    - functions (internal models) 
    - external models (executables written in C, C++, Java, FORTRAN, Julia etc.)
- should optionally allow for functional programming (with pipes)



# Required packages

```{r, message=FALSE, warning=FALSE}
library(magrittr) # piping
library(whisker)  # templating
library(readr)    # fast I/O (huge files)
library(purrr)    # functional programming tools
library(dplyr)    # a grammar of data manipulation
library(raster)   # raster analysis
```



# Error propagation with R functions

The simplest ways to do error propagation is by means of R-functions. This does not require any additional code. All functionality is already shipped with R or its package ecosystem.

As an example, consider the function `foo` that requires three parameters. Error propagation can be implemented as follows:


```{r}

# define demo function: explanatory variable x and two parameters b0 and b1
foo <- function(x, b0, b1) {
    b0 + b1 * x
}

# number of realizations
n_realizations <- 100

# explanatory variable
n <- 9
x <- 1:n

# call foo once (for testing)
foo(x = x, b0 = 1, b1 = 2)



# example 1: error propagation of parameter uncertainty
# the output will be processed and summarised as percentiles
# (with piping, see magnificent purrr-package)
n_realizations %>%
    rerun(foo(x = x, b0 = rnorm(n = 1), b1 = runif(n = 1))) %>%
    set_names(paste0("r", 1:n_realizations)) %>% 
    as_data_frame %>%
    apply(MARGIN = 1, FUN = quantile, probs = 0:10/10) %>%
    round(3)


# example 2: as example 1, but with existing realizations
# of the parameters

# create existing realizations 
# (can also be read from a file
d <- list(
    b0 = rnorm(n = n_realizations), 
    b1 = runif(n = n_realizations)
)
d %>% glimpse

# error propagation
d %>%
    pmap(foo, x) %>%
    set_names(paste0("r", 1:n_realizations)) %>% 
    as_data_frame %>%
    apply(MARGIN = 1, FUN = quantile, probs = 0:10/10) %>%
    round(3)


# example3: error propagation of input uncertainty
n_realizations %>%
    rerun(foo(x = x + rnorm(n = n), b0 = 1, b1 = 2)) %>%
    set_names(paste0("r", 1:n_realizations)) %>% 
    as_data_frame %>%
    apply(MARGIN = 1, FUN = quantile, probs = 0:10/10) %>%
    round(3)


```


Run these functions line-by-line to get a better understanding of what is going on.




# Error propagation with existing realizations


```{r}

# load three realizations of a DEM (demp_samp) 
# source Kasia (Wed 2016-09-21 16:46)
load("DEM.RData") 

# compute and plot difference of maximum and minimum value per grid cell
dem_samp_variation <- dem_samp %>%
    brick %T>%
    plot(main = "DEM") %>%
    calc(function(x){max(x) - min(x)}) %T>%
    plot(main = "max-min")
```





# Error propagation with external functions

When using external models we need additional code to

1. modify ASCII input files
1. run the external model




## Modify ASCII input files (rendering)

For rendering ASCII input files, we use the mustache templating framework (https://mustache.github.io). In R this is implemented in the package `whisker`.

First we define a 'container' class to store all templates with model inputs. The aim of this class is to

1. organise model input files;
1. perform some checks


The constructor of this class is given below:

```{r}
template <- function(filenames) {
    filenames %>% 
        walk(
            function(x) {
                if (!grepl(pattern = "\\.template$", x = x)) {
                    stop(
                        "File %s does not have extension 'template'" %>% 
                            sprintf(x %>% sQuote), 
                        call. = FALSE
                    )
                }
            }
        )
    filenames %>% 
        walk(
            function(x) {
                if (!file.exists(x)) {
                    stop(
                        "File %s not found" %>% 
                            sprintf(x %>% sQuote), 
                        call. = FALSE
                    )
                }
            }
        )
    class(filenames) <- "template"
    filenames
}

print.template <- function(x, ...) {
    cat("container containing the following template(s):\n")
    print(as.character(x))
}
```



A template is simply a model input file with:

1. the additional extension `.template`. 
1. input that needs to be modified is replaced by mustache-style tags. 


For example, suppose a model needs the input file: `input.txt`. Suppose further that this input file contains two parameters b0 and b1. The contents of the original file may look like:

```{r}
read_lines("./templating/input.txt")
```

where the first number is `b0` and the second number is `b1`.

Then, the corresponding template file should have filename `input.txt.template`. It contains:

```{r}
read_lines("./templating/input.txt.template")
```

So, the original numbers are replaced by symbols b0 and b1 placed in moustaches `{{` and `}}`.




Rendering is the process of replacing the tags in moustaches by text. For this, we provide a set of render-methods.

```{r}

render <- function(x, ...) {
    UseMethod("render")
}

render.character <- function(x, ...) {
    dots <- list(...)
    if (length(dots) == 0L) {
        return(x)
    }
    x %>% 
        whisker.render(dots)
}

render.template <- function(x, ...) {
    sub(pattern = "\\.template$", replacement = "", x = x) %T>% 
        walk(function(x) {
            readLines(paste(x, "template", sep = "."), warn = FALSE) %>% 
            render(...) %>%
            writeLines(x)
        }) %>%
        as.character
}

```



For example:
```{r}
my_template <- "Hello {{name}}. How are you doing?"

my_template %>% 
    render(name = "Kasia")

```

This example calls `render.character`. It is also possible to fill out an entire table:

```{r}
my_template <- c(
    "| x | y |",
    "|---|---|",
    "{{#MY_TABLE}}",
        "| {{X}} | {{Y}} |",
    "{{/MY_TABLE}}"
)

my_table <- data.frame(X = 1:5, Y = letters[1:5])
my_table

my_template %>% 
    render(MY_TABLE = unname(rowSplit(my_table))) %>%
    cat
```

See the `whisker`-package (or https://mustache.github.io) for more information on the syntax. 


A template stored as a file will always be rendered on disk. Let's return to our template:

```{r}
my_template <- template("templating/input.txt.template")
```

with contents

```{r}
my_template %>% 
    read_lines
```


Rendering will create a new file, called `input.txt`.

```{r}
my_template %>% 
    render(b0 = 3, b1 = 4)
```

As can be seen above, the path of this file is also the return value of the render method. This facilitates further processing by means of the pipe-operator:

```{r}
my_template %>% 
    render(b0 = 3, b1 = 4) %>%
    read_lines
```



## Running external models

An external model can always be called from R by means of the `system` or `system2` function. To facilitate this, the following wrapper function comes in handy:

```{r}
executable <-
function(filename) {
    if (!file.exists(filename)) {
        stop(
            "%s not found" %>% sprintf(sQuote(filename)), 
            call. = FALSE
        )
    }
    function() {
        root <- dirname(filename)
        owd <- setwd(root)
        on.exit(setwd(owd))
        system2(basename(filename), wait = TRUE)
    }
}
```


Suppose we got an external model written in the C language: `kasia.C`. The executable on MS-Windows is called `kasia.exe`. We can now wrap this model as follows:

```{r}
kasia <- executable("./templating/kasia.exe")
```


Running this model gives
```{r}
# create template
my_template <- template("./templating/input.txt.template")

# render the template
render(my_template, b0 = 3.1, b1 = 4.2)

# run external model
kasia()

# read output (output file of kasia-model is "output.txt")
scan(file = "./templating/output.txt", quiet = TRUE)
```


An example of multiple realizations:
 
 1. render template
 1. run model
 1. read results
 1. process results

```{r}

n_realizations <- 100

n_realizations %>%
    rerun({
        # render template
        render(my_template, b0 = rnorm(n = 1), b1 = runif(n = 1))
        
        # run model
        kasia()

        # read output
        scan("d:/Projects/QUICS/templating/output.txt", quiet = TRUE)
    }) %>%
    set_names(paste0("r", 1:n_realizations)) %>% 
    as_data_frame %>%
    apply(MARGIN = 1, FUN = quantile)    
```

